#summary Some quick examples what PyCow - the Python to !JavaScript translator - does
#labels Featured,Phase-Implementation

= Introduction =

The implementation of !PyGoWave Server produces some nice by-products. !PyCow is one of them.

!PyCow translates Python code to !JavaScript code with the "!MooTools way of class declaration".

It generally depends on the fact that !JavaScript shares almost all of its semantics with Python, so !PyCow just has to change the syntax most of the time.

= Examples =

The behavior of !PyCow can be seen at best on some examples.

Note: !PyCow currently removes any comments in the code.

== Classes, subclasses and functions ==

*Python:*
{{{
class Someclass:
    """
    Docstring of class
    """
    def __init__(self, something): # PyCow removes 'self' from method declarations
        """
        Docstring of constructor/method
        """
        self.something = something + "string literal" # PyCow replaces 'self' with 'this'
    
    def a_method(self, otherthing):
        print self.something + otherthing # 'print' is translated to 'alert'
    
    def another_method(self):
        obj = SomeExtension() # PyCow can infer types of callables (even declared later); here it will place 'new', because SomeExtension is a class
        self.member = "test"

class SomeExtension(Someclass):
    def __init__(self):
        super(SomeExtension, self).__init__("1234") # PyCow correctly treats the 'super' function of Python; here it's the call to the super constructor
    
    def a_method(self, otherthing):
        super(SomeExtension, self).a_method(otherthing) # Here it's a call to the super class' method
        print otherthing, self.something

def a_function():
    """
    Docstring of function
    
    Note that PyCow removes
            whitespaces.
    
    
    
    And normalizes newlines.
    """
    test = 2 # PyCow automatically declares local variables
    test = 4 # once
    print test+     2 # Because PyCow parses semantics only, it will ignore whitespaces (but avoid to do something like that anyways)

obj = Someclass()

obj.a_method("test") # PyCow's type inference does not include types of variables (atm)

a_function() # PyCow does not put "new" here, because a_function is a simple function
}}}

*Resulting !JavaScript:*
{{{
/**
 * Docstring of class
 */
var Someclass = new Class({
    /**
     * Docstring of constructor/method
     */
    initialize: function (something) {
        this.something = something + "string literal";
    },
    a_method: function (otherthing) {
        alert(this.something + otherthing);
    },
    another_method: function () {
        var obj = new SomeExtension();
        this.member = "test";
    }
};

var SomeExtension = new Class({
    Extends: Someclass,
    initialize: function () {
        this.parent("1234");
    },
    a_method: function (otherthing) {
        this.parent.a_method(otherthing);
        alert(otherthing + " " + this.something);
    }
};

/**
 * Docstring of function
 *
 * Note that PyCow removes
 * whitespaces.
 *
 * And normalizes newlines.
 */
var a_function = function () {
    var test = 2;
    test = 4;
    alert(test + 2);
};

var obj = new Someclass();
/* Warning: Cannot infer type of -> */ obj.a_method("test");
a_function();
}}}

== Variable scope ==

*Python:*
{{{
global x # Because of the 'global' statement
x = "hello again" # PyCow does not declare x as local here

def another_function():
    global x
    x = "go ahead" # and here
    return x
}}}

*Resulting !JavaScript:*
{{{
x = "hello again";
var another_function = function () {
    x = "go ahead";
    return x;
};
}}}

== If/else statement ==

*Python:*
{{{
if True:
    print "Welcome"
    if False:
        pass
    else:
        print "Nested if"
else:
    print "You're not welcome..."
}}}

*Resulting !JavaScript:*
{{{
if (true) {
    alert("Welcome");
    if (false)
        /* pass */;
    else
        alert("Nested if");
}
else
    alert("You're not welcome...");
}}}

== While statement ==

*Python:*
{{{
i = 0
while i < 3: # While statement
    print i
    i += 1 # Assignment operator
}}}

*Resulting !JavaScript:*
{{{
var i = 0;
while (i < 3) {
    alert(i);
    i += 1;
}
}}}

== For statement ==

*Python:*
{{{
for j in xrange(3): # For statement (xrange)
    print j
for j in xrange(1,4): # For statement (xrange; with start)
    print j
for j in xrange(1,4,2): # For statement (xrange; with start and step)
    print j
for j in xrange(4,1,-1): # For statement (xrange; with start and step backwards)
    print j
}}}

*Resulting !JavaScript:*
{{{
for (var j = 0; j < 3; j++)
    alert(j);
for (j = 1; j < 4; j++)
    alert(j);
for (j = 1; j < 4; j += 2)
    alert(j);
for (j = 4; j > 1; j--)
    alert(j);
}}}

== Lists and dictionaries ==

*Python:*
{{{
f = lambda x: x*2 # Lambda functions

a = [1,2,3,f(2)] # List expression

print a[1:3] # Slicing

b = {} # Empty dictionary

# Dictionary with strings and numbers as indices
b = {"a": 1, "b": 2,
     1: "x", 2: "y",
     "-test-": 1+2, "0HAY0": "a"+"B"}

# Accessing subscript (simple string)
print b["a"]

# Accessing subscript (other string; assignment)
b["-test-"] = 3

# Accessing subscript (number)
print b[1]

# Deleting from map
del b["a"]
}}}

*Resulting !JavaScript:*
{{{
var f = function (x) {return x * 2;};
var a = [1, 2, 3, /* Warning: Cannot infer type of -> */ f(2)];
alert(a.slice(1, 3));
var b = {};
b = {
    a: 1,
    b: 2,
    1: "x",
    2: "y",
    "-test-": 1 + 2,
    "0HAY0": "a" + "B"
};
alert(b.a);
b["-test-"] = 3;
alert(b[1]);
delete b.a;
}}}