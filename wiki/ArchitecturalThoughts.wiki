#summary Look before you leap or run into the thick of it?

= Introduction =

I decided to write a quick-and-dirty Google Wave Server which shall constantly evolve into full-featured production-ready software. This implies, that writing the server is an iterative process.

The tradeoff of trying to be as fast as possible is a certain tendency to, simply spoken, go the wrong way and maybe to reach dead ends in software engineering. So I sat down, took a breath and carefully thought up a plan.

= The Server Architecture =

After reading the API up and down and having taken a glimpse at the Federation Protocol specification I came to the following points:

=== From the Federation Protocol's View ===

 * A Wave is a container for Wavelets; it has at least one Wavelet which is the root Wavelet
 * Wavlets spawn by writing data to a theoretically existing Wavelet, it is created if it didn't exist before
 * A Wavelet is a standard XML document with some constraints; additionaly Wavelets have participants (with a set of permissions) and annotations (that handle styling)
 * There are no semantics in the Wavelet Document's content; things like Blips or Gadgets are simple XML tags like any other
 * A sophisticated technique is used to maintain mutations to the Wavelet - called "Deltas" and "Wavelet operations"
 * Data is exchanged through the (strictly) defined Federation Protocol

=== From the Robot API's View ===

 * Everything is accessed through an object model; there is no XML document
 * The Wave only exists as an ID string; Robots cannot get access to a list of Wavelets on a Wave
 * A Wavelet is an Object that consists of participants, Data Documents and Blips
 * Blips have a hierarchy, they have contributors, a creator and a Document
 * The Document in a Blip has annotations, raw text, Gadgets and Form Elements
 * Mutations to the Wavelet are specified by Events from the server side and Operations from the client side
 * Data is exchanged through a proprietary protocol; at the time of writing this follows a request-response scheme with JSON-marshalled Java objects; there are no "Deltas" like in the Federation Protocol

=== From the Google Wave Client's View ===

 * Nothing has been spread to the public how the client works behind the scenes so far

=== From the Gadget API's View ===

 * A Gadget only maintains its own state and only gets a few hints what happens in the Wavelet
 * Its state is represented with a one-dimensional JavaScript map
 * Data is exchanged on behalf of the Google Gadgets API; it is obviously fed to the Google Wave Client

== How could a server be implemented then? ==
_My first approach, and why I went for it._

*Focus on the API's protocol*

  As long as there are no other Wave Servers and I am not able to communicate with Google's, I'll stick with the Robots and Gadgets.

*Maintain the API's object model*

  This allows me to rapidly establish a working communication with Robots and Gadgets. For implementing the Federation Protocol it's quite a bit cumbersome.

*Create a Google Gadgets / Google Wave emulation environment*

  Without access to the Google Wave Client I am foreced to build my own client too. This is a heavy task that I cannot accomplish in time (the presentation of Google Wave totally overwhelmed me at this point, so I won't even try).

  However, it should be possible at least to get some Gadgets running in a tiny Wave-wannabe environment. To stay compatible with existing Gadgets I'll implement those few Google Gadgets API calls by myself.

*Choose Python*

  Platform independency, clearity, nice design of the language, the ease and speed of writing working programs and much more are my reasons for choosing Python. I could write a feature-length hymn for this language.

*Choose Django (and jQuery)*

  With Django, a persistent object model can be created in a few hours (as you have probably seen). Because of the request-response scheme of the Robot API there shouldn't be a problem to shove those events and context into a robot.

  jQuery is my key to AJAX programming. It interacts nicely with Django, too. Also it won't be hard to build that Gadget API emulation script with this.

  After all, you want to administer your Wave Server through some sort of Web Interface - Ok, a Wave and/or Gadget would do the trick too. At least something must serve those IFrames and JavaScripts...

== What's with the Federation Protocol? ==

I think of emulating the XML Wavelet document with my object model. This requires some more thinking and even more work to be done, but will keep things straight for Robots and, let's say thin-clients :)

The Python Twisted Framework seems to be more adequate for those XAMPP things. Maybe I can connect it somehow to the Django-part of !PyGoWave. It's also possible that I'll migrate everything to Twisted at a later time of development.

= Conclusion =

So that's what will become !PyGoWave Server. More things to come soon. If you want to provide any feedback feel free to spam into my [http://groups.google.com/group/google-wave-api/browse_thread/thread/57190718d928ac27 discussion thread at Google Groups].
I'm always open to suggestions on how to make this thing better.